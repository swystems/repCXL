// YCSB trace file parser.
//
// Parses load and run trace files generated by YCSB via BasicDB into
// structured workload data that can be replayed by benchmark binaries.
//
// Trace file format:
//   ***************** properties *****************
//   "key"="value"
//   ...
//   **********************************************
//   INSERT usertable user1234567890 [ field0=<63-byte value> ]
//   READ usertable user1234567890 [ <all fields>]
//   UPDATE usertable user1234567890 [ field0=<63-byte value> ]
//
// All operations are single-line (values may appear wrapped in a terminal
// but each operation is one line in the file).
// Summary statistics lines (e.g. [INSERT], ...) at the end are skipped.

use std::collections::HashMap;
use std::fs;

#[derive(Debug, Clone, PartialEq)]
pub enum OpType {
    Insert,
    Read,
    Update,
    // Scan,
    // ReadModifyWrite,
}

/// YCSB workload properties parsed from the trace file header.
#[derive(Debug, Clone)]
pub struct WorkloadProperties {
    pub record_count: usize,
    pub operation_count: usize,
    pub field_count: usize,
    pub field_length: usize,
    pub read_proportion: f64,
    pub update_proportion: f64,
    pub insert_proportion: f64,
    pub scan_proportion: f64,
    pub request_distribution: String,
    /// All raw key-value pairs from the properties header.
    pub raw: HashMap<String, String>,
}

/// A single YCSB operation with its associated data.
#[derive(Debug, Clone)]
pub struct YcsbOp {
    pub op_type: OpType,
    pub table: String,
    pub key: String,
    /// Field values for INSERT and UPDATE operations.
    /// Empty for READ operations.
    pub fields: Vec<(String, Vec<u8>)>,
}

/// Complete parsed YCSB workload with load and run phases.
#[derive(Debug)]
pub struct YcsbWorkload {
    pub properties: WorkloadProperties,
    pub load_ops: Vec<YcsbOp>,
    pub run_ops: Vec<YcsbOp>,
}

impl YcsbWorkload {
    pub fn summary(&self) {
        println!("\nYCSB workload\n  {} load ops, {} run ops", self.load_ops.len(), self.run_ops.len());
        println!("  record_count={}, field_count={}, field_length={}",
            self.properties.record_count, self.properties.field_count, self.properties.field_length);
        println!("  read={}, update={}, insert={}, scan={}",
            self.properties.read_proportion, self.properties.update_proportion,
            self.properties.insert_proportion, self.properties.scan_proportion);
        println!("  distribution={}", self.properties.request_distribution);

        let unique_keys: std::collections::HashSet<&str> = self.load_ops.iter()
            .chain(self.run_ops.iter())
            .map(|op| op.key.as_str())
            .collect();
        println!("  unique keys: {}\n", unique_keys.len());
    }
}

// ---------------------------------------------------------------------------
// Parsing
// ---------------------------------------------------------------------------

/// Parse the `"key"="value"` properties block between the `*****` delimiters.
fn parse_properties(lines: &[&str]) -> (WorkloadProperties, usize) {
    let mut raw = HashMap::new();
    let mut i = 0;

    // Skip until we hit the opening delimiter.
    while i < lines.len() && !lines[i].contains("*****") {
        i += 1;
    }
    i += 1; // skip the delimiter line itself

    // Read key=value pairs until the closing delimiter.
    while i < lines.len() && !lines[i].contains("*****") {
        let line = lines[i].trim();
        if let Some((k, v)) = line.split_once('=') {
            let k = k.trim().trim_matches('"').to_string();
            let v = v.trim().trim_matches('"').to_string();
            raw.insert(k, v);
        }
        i += 1;
    }
    i += 1; // skip the closing delimiter

    let get_f64 = |key: &str| -> f64 {
        raw.get(key).and_then(|v| v.parse().ok()).unwrap_or(0.0)
    };
    let get_usize = |key: &str| -> usize {
        raw.get(key).and_then(|v| v.parse().ok()).unwrap_or(0)
    };

    let props = WorkloadProperties {
        record_count: get_usize("recordcount"),
        operation_count: get_usize("operationcount"),
        field_count: get_usize("fieldcount"),
        field_length: get_usize("fieldlength"),
        read_proportion: get_f64("readproportion"),
        update_proportion: get_f64("updateproportion"),
        insert_proportion: get_f64("insertproportion"),
        scan_proportion: get_f64("scanproportion"),
        request_distribution: raw.get("requestdistribution")
            .cloned().unwrap_or_default(),
        raw,
    };

    (props, i)
}

/// Parse the value from a field assignment like `field0=<value...>`.
/// The value is between `[ ` and the trailing ` ]` on the same line.
fn parse_field_value(line: &str) -> Vec<(String, Vec<u8>)> {
    // Find `[ field0=...` on the line.
    let bracket_pos = match line.find("[ ") {
        Some(p) => p,
        None => return Vec::new(),
    };
    let inside = &line[bracket_pos + 2..]; // after "[ "

    // Strip the trailing " ]".
    let content = inside.strip_suffix(']')
        .unwrap_or(inside)
        .trim_end();

    // Parse individual field assignments (field0=val field1=val ...).
    let mut fields = Vec::new();
    // Simple case: single field (fieldcount=1 in most workloads).
    if let Some((name, value)) = content.split_once('=') {
        let name = name.trim().to_string();
        let value = value.as_bytes().to_vec();
        fields.push((name, value));
    }

    fields
}

/// Parse operations from lines starting at `start`. Each operation is a
/// single line:
///   READ usertable <key> [ <all fields>]
///   INSERT/UPDATE usertable <key> [ field0=<value> ]
/// Summary stats lines (starting with `[`) are skipped.
fn parse_operations(lines: &[&str], start: usize) -> Vec<YcsbOp> {
    let mut ops = Vec::new();

    for &line in &lines[start..] {
        let line = line.trim();

        // Skip empty lines, comments, and YCSB summary statistics.
        if line.is_empty() || line.starts_with('#') || line.starts_with('[') {
            continue;
        }

        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() < 3 {
            continue;
        }

        let op_type = match parts[0] {
            "INSERT" => OpType::Insert,
            "READ" => OpType::Read,
            "UPDATE" => OpType::Update,
            // "SCAN" => OpType::Scan,
            // "READ-MODIFY-WRITE" => OpType::ReadModifyWrite,
            _ => continue,
        };

        let table = parts[1].to_string();
        let key = parts[2].to_string();

        let fields = match op_type {
            OpType::Read => Vec::new(),
            _ => parse_field_value(line),
        };

        ops.push(YcsbOp { op_type, table, key, fields });
    }

    ops
}

/// Read and parse a YCSB trace file into its properties and operation list.
pub fn parse_ycsb_trace(path: &str) -> (WorkloadProperties, Vec<YcsbOp>) {
    let content = fs::read_to_string(path)
        .unwrap_or_else(|e| panic!("Failed to read YCSB trace file '{}': {}", path, e));

    let lines: Vec<&str> = content.lines().collect();
    let (properties, ops_start) = parse_properties(&lines);
    let operations = parse_operations(&lines, ops_start);

    (properties, operations)
}

/// Load a complete YCSB workload from separate load and run trace files.
pub fn load_ycsb_workload(load_path: &str, run_path: &str) -> YcsbWorkload {
    let (properties, load_ops) = parse_ycsb_trace(load_path);
    let (_run_props, run_ops) = parse_ycsb_trace(run_path);

    YcsbWorkload { properties, load_ops, run_ops }
}
